# 3.6. Arquitetura do Sistema - L√≥gica e F√≠sica

## Sum√°rio

- [1. Decis√µes Arquiteturais](#1-decis√µes-arquiteturais)
- [2. Persist√™ncia Poliglota](#2-persist√™ncia-poliglota)
- [3. Arquitetura L√≥gica](#3-arquitetura-l√≥gica)
- [4. Arquitetura F√≠sica](#4-arquitetura-f√≠sica)
- [5. Integra√ß√£o entre M√≥dulos](#5-integra√ß√£o-entre-m√≥dulos)
- [6. Benef√≠cios e Desafios](#6-benef√≠cios-e-desafios)

---

## 1. Decis√µes Arquiteturais

### Por que Microsservi√ßos?

**Decis√£o**: Dividir o sistema em 3 m√≥dulos independentes (Cadastro, Agendamento, Estoque)

**Justificativa**:

1. **Escalabilidade Independente**: Cada m√≥dulo pode escalar conforme demanda
   - Cadastro: baixa frequ√™ncia, alta consist√™ncia
   - Agendamento: alta frequ√™ncia em hor√°rios espec√≠ficos
   - Estoque: m√©dia frequ√™ncia, picos em hor√°rios de dispensa√ß√£o

2. **Tecnologias Espec√≠ficas**: Cada m√≥dulo usa o banco mais adequado para seu dom√≠nio

3. **Resili√™ncia**: Falha em um m√≥dulo n√£o derruba o sistema todo

4. **Desenvolvimento Paralelo**: Times diferentes podem trabalhar simultaneamente

---

## 2. Persist√™ncia Poliglota

O SimpleHealth implementa **persist√™ncia poliglota**, onde cada m√≥dulo utiliza o banco de dados mais adequado √†s suas necessidades:

### M√≥dulo Cadastro: PostgreSQL + Cassandra + Redis

#### PostgreSQL 16 (Banco Principal)

**Porta**: 5430

**Por qu√™?**

1. **Consist√™ncia ACID**: Dados de pacientes/m√©dicos requerem transa√ß√µes confi√°veis
2. **Relacionamentos Complexos**: JOINs entre Paciente ‚Üî Conv√™nio ‚Üî M√©dico
3. **Queries Complexas**: Busca por CPF, nome, especialidade m√©dica
4. **Maturidade**: Banco robusto, bem documentado

**Trade-offs**:

- ‚úÖ Consist√™ncia forte
- ‚úÖ Queries relacionais
- ‚ùå Escalabilidade horizontal limitada
- ‚ùå Menor performance em alt√≠ssimo volume

**Entidades**: Paciente, M√©dico, Usu√°rio, Conv√™nio

#### Cassandra 5 (Dados de Auditoria)

**Porta**: 9042

**Por qu√™?**

1. **Alta Disponibilidade**: Logs de auditoria n√£o podem ser perdidos
2. **Write-Heavy**: Milhares de eventos de auditoria por dia
3. **Time Series**: Dados ordenados por timestamp
4. **Escalabilidade**: Preparado para crescimento futuro

**Trade-offs**:

- ‚úÖ Alta disponibilidade (sem single point of failure)
- ‚úÖ Write performance excelente
- ‚úÖ Escalabilidade horizontal f√°cil
- ‚ùå Queries limitadas (sem JOINs)
- ‚ùå Eventual consistency

**Entidades**: EventoAuditoria

#### Redis 7 (Cache)

**Porta**: 6380

**Por qu√™?**

1. **Performance**: Cache de listas de m√©dicos dispon√≠veis (consulta frequente)
2. **Session Storage**: Sess√µes de usu√°rios logados
3. **Pub/Sub**: Comunica√ß√£o entre m√≥dulos (alertas de estoque cr√≠tico)

**Trade-offs**:

- ‚úÖ Performance alt√≠ssima (in-memory)
- ‚úÖ Estruturas de dados ricas (Lists, Sets, Hashes)
- ‚ùå Volatilidade (n√£o √© banco prim√°rio)
- ‚ùå Limitado pela RAM

---

### M√≥dulo Agendamento: MongoDB + Redis

#### MongoDB 6.0

**Porta**: 27017

**Por qu√™?**

1. **Flexibilidade**: Consultas, Exames e Procedimentos t√™m estruturas diferentes
2. **Schema-less**: Facilita evolu√ß√£o dos tipos de agendamento
3. **Embedded Documents**: Agenda m√©dica pode ter disponibilidades embutidas
4. **Queries Geoespaciais**: Futuro - agendar por localiza√ß√£o

**Trade-offs**:

- ‚úÖ Flexibilidade de schema
- ‚úÖ Performance boa para reads/writes
- ‚úÖ Escalabilidade horizontal (sharding)
- ‚ùå Sem transa√ß√µes ACID completas (at√© vers√£o 4.0)
- ‚ùå Queries relacionais menos eficientes

**Entidades**: Consulta, Exame, Procedimento, BloqueioAgenda

#### Redis 7 (Cache)

**Porta**: 6379

**Por qu√™?**

1. **Cache de Agendas**: Disponibilidade de m√©dicos (consulta a cada clique)
2. **Locks Distribu√≠dos**: Evitar double-booking de hor√°rios

---

### M√≥dulo Estoque: Cassandra + Redis

#### Cassandra 5

**Porta**: 9042

**Por qu√™?**

1. **Alta Disponibilidade**: Estoque cr√≠tico n√£o pode ficar offline
2. **Write-Heavy**: Movimenta√ß√µes constantes de entrada/sa√≠da
3. **Particionamento Natural**: Dados por localizacao/setor/tipo
4. **Time Series**: Hist√≥rico de movimenta√ß√µes ordenado por tempo

**Trade-offs**:

- ‚úÖ Alta disponibilidade
- ‚úÖ Escalabilidade horizontal
- ‚úÖ Performance em writes
- ‚ùå Queries complexas dif√≠ceis
- ‚ùå Modelagem exige planejamento (denormaliza√ß√£o)

**Entidades**: Medicamento, Alimento, Hospitalar, Fornecedor, Estoque, Pedido, Item

#### Redis 7 (Cache + Pub/Sub)

**Porta**: 6381

**Por qu√™?**

1. **Cache de Estoque Cr√≠tico**: Lista de itens abaixo do m√≠nimo
2. **Pub/Sub**: Alertas para m√≥dulo Cadastro quando estoque cr√≠tico

---

### üìä Compara√ß√£o de Bancos

| Banco | Tipo | Consist√™ncia | Escalabilidade | Casos de Uso |
|-------|------|--------------|----------------|--------------|
| **PostgreSQL** | Relacional | ACID (Forte) | Vertical | Cadastros, transa√ß√µes |
| **MongoDB** | Documento | Eventual | Horizontal | Agendamentos flex√≠veis |
| **Cassandra** | Wide-Column | Eventual | Horizontal | Auditoria, logs, estoque |
| **Redis** | Key-Value | Forte (single-node) | Vertical | Cache, pub/sub, sessions |

---

## 3. Arquitetura L√≥gica

A arquitetura l√≥gica define a organiza√ß√£o do software, seus componentes e suas responsabilidades, independentemente do hardware onde ser√£o executados.

O sistema √© dividido **verticalmente** em **Parti√ß√µes/Subsistemas** que representam os m√≥dulos de neg√≥cio (Cadastro, Agendamento, Estoque). Cada parti√ß√£o √© organizada **horizontalmente** em **quatro camadas l√≥gicas**:

### 3.1 Camadas do Sistema

#### 1. Camada de Apresenta√ß√£o (UI)

**O que √©**: Interface com o usu√°rio, respons√°vel por exibir informa√ß√µes e capturar entradas.

**No projeto**: 
- **Interface Desktop JavaFX**: Tr√™s aplica√ß√µes frontend independentes
- Comunica√ß√£o via HTTP/REST com os backends

#### 2. Camada de Aplica√ß√£o (Servi√ßos)

**O que √©**: Cont√©m a l√≥gica de coordena√ß√£o dos casos de uso e os servi√ßos que o frontend consome.

**No projeto**: Tr√™s servi√ßos principais independentes:

- **CadastroService**: Orquestra UC01-UC05 (Cadastrar Paciente, M√©dico, Usu√°rio, Conv√™nio, Autentica√ß√£o)
- **AgendamentoService**: Orquestra UC06-UC09 (Agendar Consulta, Exame, Procedimento, Bloqueios)
- **EstoqueService**: Orquestra UC10-UC16 (Gest√£o de Medicamentos, Alimentos, Materiais, Fornecedores, Pedidos)

#### 3. Camada de Dom√≠nio (Neg√≥cio)

**O que √©**: O cora√ß√£o do software. Cont√©m as regras de neg√≥cio e as entidades principais.

**No projeto**: Cada servi√ßo gerencia seu pr√≥prio conjunto de entidades:

- **Dom√≠nio de Cadastro**: Paciente, M√©dico, Usu√°rio, Conv√™nio
- **Dom√≠nio de Agendamento**: Consulta, Exame, Procedimento, BloqueioAgenda
- **Dom√≠nio de Estoque**: Medicamento, Alimento, Hospitalar, Fornecedor, Pedido, Item

#### 4. Camada de Infraestrutura (T√©cnica)

**O que √©**: Fornece servi√ßos t√©cnicos gen√©ricos (acesso a dados, comunica√ß√£o, cache).

**No projeto**: Dividida em duas partes:

- **Persist√™ncia (Repositories)**: Interfaces para acesso aos bancos de dados
  - Spring Data JPA (PostgreSQL)
  - Spring Data MongoDB
  - Spring Data Cassandra
- **Integra√ß√£o (Middleware)**: Redis Pub/Sub para comunica√ß√£o ass√≠ncrona entre m√≥dulos

### 3.2 Diagrama PlantUML - Arquitetura L√≥gica

```plantuml
@startuml

skinparam package {
  BorderColor DarkSlateGray
  BackgroundColor PaleGreen
}

skinparam component {
  BorderColor DarkSlateGray
  BackgroundColor LightYellow
  ArrowColor Firebrick
}

skinparam ArrowColor Firebrick

!define SUBSYSTEM package "<<subsystem>>"

' Defini√ß√£o das Camadas L√≥gicas
package "1. Camada de Apresenta√ß√£o (UI)" as UI {
  SUBSYSTEM "Interface Desktop JavaFX" as UI_Desktop {
    [Frontend Cadastro]
    [Frontend Agendamento]
    [Frontend Estoque]
  }
}

package "2. Camada de Aplica√ß√£o (Servi√ßos)" as App {
  SUBSYSTEM "Servi√ßos de Cadastro" as App_Cadastro {
    [CadastroService]
    [PacienteService]
    [MedicoService]
  }
  
  SUBSYSTEM "Servi√ßos de Agendamento" as App_Agendamento {
    [AgendamentoService]
    [ConsultaService]
    [ExameService]
  }
  
  SUBSYSTEM "Servi√ßos de Estoque" as App_Estoque {
    [EstoqueService]
    [MedicamentoService]
    [FornecedorService]
  }
}

package "3. Camada de Dom√≠nio (Neg√≥cio)" as Domain {
  SUBSYSTEM "Dom√≠nio de Cadastro" as Dom_Cadastro {
    [Paciente]
    [Medico]
    [Usuario]
  }
  
  SUBSYSTEM "Dom√≠nio de Agendamento" as Dom_Agendamento {
    [Consulta]
    [Exame]
    [Procedimento]
  }
  
  SUBSYSTEM "Dom√≠nio de Estoque" as Dom_Estoque {
    [Medicamento]
    [Alimento]
    [Hospitalar]
  }
}

package "4. Camada de Infraestrutura (T√©cnica)" as Infra {
  SUBSYSTEM "Persist√™ncia (Repositories)" as Infra_Repo {
    [PacienteRepository - JPA]
    [ConsultaRepository - MongoDB]
    [MedicamentoRepository - Cassandra]
  }
  
  SUBSYSTEM "Integra√ß√£o (Middleware)" as Infra_Bus {
    [Redis Pub/Sub]
    [Redis Cache]
  }
}

' Depend√™ncias de Camada
UI --> App : HTTP/REST
App --> Domain : Usa
App --> Infra_Repo : Persiste
Domain --> Infra_Repo : Mapeado para

' Depend√™ncias de Integra√ß√£o (Desacopladas)
App_Cadastro ..> Infra_Bus : <<publica eventos>>
App_Agendamento ..> Infra_Bus : <<publica/consome>>
App_Estoque ..> Infra_Bus : <<publica/consome>>

note right of Infra_Bus
  Redis permite comunica√ß√£o
  ass√≠ncrona entre m√≥dulos
  sem depend√™ncia direta
end note

@enduml
```

**Diagrama Gerado:**

![Arquitetura L√≥gica](images/image1.png)

**Para visualizar**: Copie o c√≥digo acima e cole em [PlantUML Online](http://www.plantuml.com/plantuml/uml/) ou use a extens√£o PlantUML no VS Code.

---

## 4. Arquitetura F√≠sica

A arquitetura f√≠sica mostra como os componentes de software s√£o distribu√≠dos em n√≥s de processamento f√≠sicos (hardware, servidores, containers).

### 4.1 N√≥s de Processamento

#### N√≥ 1: Cliente Desktop

- **Hardware**: Computador do usu√°rio (Windows/Linux/Mac)
- **Software**: Aplica√ß√µes JavaFX (Cadastro, Agendamento, Estoque)
- **Comunica√ß√£o**: HTTP/REST para backends

#### N√≥ 2: Servidor Middleware (Redis)

- **Hardware**: Container Docker
- **Software**: Redis 7
- **Fun√ß√£o**: 
  - Pub/Sub (mensagens entre servi√ßos)
  - Cache (dados frequentemente acessados)
- **Portas**: 6379, 6380, 6381 (um para cada m√≥dulo)

#### N√≥ 3: Microsservi√ßo de Cadastro

- **Hardware**: Container Docker (Backend)
- **Software**: Spring Boot 3.5.6, Java 17
- **Porta**: 8081
- **Bancos de Dados**:
  - PostgreSQL 16 (porta 5430) - Dados mestres
  - Cassandra 5 (porta 9042) - Auditoria
  - Redis 7 (porta 6380) - Cache

#### N√≥ 4: Microsservi√ßo de Agendamento

- **Hardware**: Container Docker (Backend)
- **Software**: Spring Boot 3.5.6, Java 17
- **Porta**: 8082
- **Bancos de Dados**:
  - MongoDB 6.0 (porta 27017) - Dados de agendamento
  - Redis 7 (porta 6379) - Cache/Pub-Sub

#### N√≥ 5: Microsservi√ßo de Estoque

- **Hardware**: Container Docker (Backend)
- **Software**: Spring Boot 3.5.6, Java 17
- **Porta**: 8083
- **Bancos de Dados**:
  - Cassandra 5 (porta 9042) - Dados de estoque
  - Redis 7 (porta 6381) - Cache/Pub-Sub

### 4.2 Diagrama PlantUML - Arquitetura F√≠sica

```plantuml
@startuml

skinparam node {
  BorderColor DarkSlateGray
  BackgroundColor LightSkyBlue
}

skinparam component {
  BorderColor DarkSlateGray
  BackgroundColor LightYellow
  ArrowColor Firebrick
}

skinparam database {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
}

skinparam ArrowColor Firebrick

' N√≥ 1: Cliente Desktop
node "Cliente: Desktop\n(Windows/Linux/Mac)" as Desktop {
  component "[Frontend JavaFX\nCadastro]" as UI_Cadastro
  component "[Frontend JavaFX\nAgendamento]" as UI_Agendamento
  component "[Frontend JavaFX\nEstoque]" as UI_Estoque
}

' N√≥ 2: Middleware (Docker)
node "Container: Redis\n(Docker)" as Redis_Container {
  component "[Redis Pub/Sub\n+ Cache]" as Redis_Comp
}

' --- Microsservi√ßo de Cadastro (Docker) ---
node "Container: Backend Cadastro\n(Spring Boot :8081)" as Cadastro_Server {
  component "Microsservi√ßo\nde Cadastro" as Cadastro_Comp
}

node "Containers: Bancos Cadastro" as DB_Cadastro_Node {
  database "PostgreSQL 16\n:5430" as DB_Postgres
  database "Cassandra 5\n:9042\n(Auditoria)" as DB_Cassandra_Cad
  database "Redis 7\n:6380\n(Cache)" as Redis_Cad
}

' --- Microsservi√ßo de Agendamento (Docker) ---
node "Container: Backend Agendamento\n(Spring Boot :8082)" as Agendamento_Server {
  component "Microsservi√ßo\nde Agendamento" as Agendamento_Comp
}

node "Containers: Bancos Agendamento" as DB_Agendamento_Node {
  database "MongoDB 6.0\n:27017" as DB_Mongo
  database "Redis 7\n:6379\n(Cache)" as Redis_Agend
}

' --- Microsservi√ßo de Estoque (Docker) ---
node "Container: Backend Estoque\n(Spring Boot :8083)" as Estoque_Server {
  component "Microsservi√ßo\nde Estoque" as Estoque_Comp
}

node "Containers: Bancos Estoque" as DB_Estoque_Node {
  database "Cassandra 5\n:9042" as DB_Cassandra_Est
  database "Redis 7\n:6381\n(Cache)" as Redis_Est
}

' --- Conex√µes ---
' 1. Cliente -> Servi√ßos (via HTTP REST)
UI_Cadastro ..> Cadastro_Server : "<<HTTP/REST>>"
UI_Agendamento ..> Agendamento_Server : "<<HTTP/REST>>"
UI_Estoque ..> Estoque_Server : "<<HTTP/REST>>"

' 2. Servi√ßos -> Seus pr√≥prios Bancos de Dados
Cadastro_Comp ..> DB_Postgres : "<<JPA/JDBC>>"
Cadastro_Comp ..> DB_Cassandra_Cad : "<<Cassandra Driver>>"
Cadastro_Comp ..> Redis_Cad : "<<Redis Client>>"

Agendamento_Comp ..> DB_Mongo : "<<MongoDB Driver>>"
Agendamento_Comp ..> Redis_Agend : "<<Redis Client>>"

Estoque_Comp ..> DB_Cassandra_Est : "<<Cassandra Driver>>"
Estoque_Comp ..> Redis_Est : "<<Redis Client>>"

' 3. Servi√ßos <-> Middleware (via Redis Pub/Sub)
Cadastro_Comp <..> Redis_Container : "<<Pub/Sub>>"
Agendamento_Comp <..> Redis_Container : "<<Pub/Sub>>"
Estoque_Comp <..> Redis_Container : "<<Pub/Sub>>"

note top of Redis_Container
  Redis central para
  comunica√ß√£o entre
  microsservi√ßos
end note

note bottom of Desktop
  Usu√°rios: Recepcionista,
  M√©dico, Farmac√™utico,
  Administrador
end note

@enduml
```

**Diagrama Gerado:**

![Arquitetura F√≠sica](images/image2.png)

**Para visualizar**: Copie o c√≥digo acima e cole em [PlantUML Online](http://www.plantuml.com/plantuml/uml/) ou use a extens√£o PlantUML no VS Code.

---

## 5. Integra√ß√£o entre M√≥dulos

### 5.1 Redis Pub/Sub

**Exemplo**: Alerta de Estoque Cr√≠tico

```
M√≥dulo Estoque                Redis                 M√≥dulo Cadastro
     ‚îÇ                          ‚îÇ                          ‚îÇ
     ‚îÇ  1. PUBLISH              ‚îÇ                          ‚îÇ
     ‚îÇ  "estoque:alerta"        ‚îÇ                          ‚îÇ
     ‚îÇ  { "medicamento": "X" }  ‚îÇ                          ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                          ‚îÇ
     ‚îÇ                          ‚îÇ  2. SUBSCRIBE            ‚îÇ
     ‚îÇ                          ‚îÇ  "estoque:alerta"        ‚îÇ
     ‚îÇ                          ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                          ‚îÇ  3. Mensagem recebida    ‚îÇ
     ‚îÇ                          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                          ‚îÇ                          ‚îÇ
     ‚îÇ                          ‚îÇ  4. Notifica m√©dicos     ‚îÇ
     ‚îÇ                          ‚îÇ     respons√°veis         ‚îÇ
```

**Implementa√ß√£o**:
- Publisher: `EstoqueAlertaPublisher.java` (Estoque)
- Subscriber: `EstoqueAlertaSubscriber.java` (Cadastro)

### 5.2 Fluxo de Comunica√ß√£o Completo

**Exemplo**: Agendamento de Consulta que Requer Materiais do Estoque

```
1. [Cliente Desktop JavaFX] 
   ‚Üì HTTP POST /agendamentos
   
2. [Backend Agendamento]
   ‚Üì Salva consulta no MongoDB
   ‚Üì Publica evento "ConsultaAgendada" no Redis
   
3. [Redis Pub/Sub]
   ‚Üì Retransmite mensagem para subscribers
   
4. [Backend Estoque]
   ‚Üì Recebe evento "ConsultaAgendada"
   ‚Üì Verifica materiais necess√°rios
   ‚Üì Atualiza estoque no Cassandra
   ‚Üì Publica evento "EstoqueAtualizado"
   
5. [Backend Agendamento]
   ‚Üì Recebe confirma√ß√£o de estoque
   ‚Üì Atualiza status da consulta
```

### 5.3 Caracter√≠sticas do Design

- **Baixo Acoplamento**: M√≥dulos n√£o se comunicam diretamente
- **Ass√≠ncrono**: Mensagens via Redis n√£o bloqueiam opera√ß√µes
- **Escal√°vel**: Cada m√≥dulo pode escalar independentemente
- **Resiliente**: Falha em um m√≥dulo n√£o derruba o sistema
- **Rastre√°vel**: Eventos podem ser logados para auditoria

---

## 6. Benef√≠cios e Desafios

### 6.1 Benef√≠cios da Arquitetura Poliglota

1. **Cada problema com sua solu√ß√£o ideal**
   - Cadastro: ACID com PostgreSQL
   - Agendamento: Flexibilidade com MongoDB
   - Estoque: Alta disponibilidade com Cassandra

2. **Aprendizado Tecnol√≥gico**
   - Experi√™ncia com 4 bancos de dados diferentes
   - Compreens√£o de trade-offs

3. **Prepara√ß√£o para Mundo Real**
   - Empresas usam m√∫ltiplos bancos (ex: Netflix, Uber)
   - Arquitetura reflete cen√°rios reais

### 6.2 Desafios e Complexidade

#### Complexidade Operacional

- **Problema**: Gerenciar 6 containers Docker (PostgreSQL + 3 Redis + MongoDB + 2 Cassandra)
- **Solu√ß√£o**: Scripts `start-all.sh`, `stop-all.sh`, `status.sh`

#### Consist√™ncia Entre M√≥dulos

- **Problema**: Eventual consistency entre m√≥dulos
- **Solu√ß√£o**: Design aceita inconsist√™ncias tempor√°rias (n√£o cr√≠tico para o dom√≠nio)

#### Aprendizado

- **Problema**: Curva de aprendizado de 4 tecnologias
- **Solu√ß√£o**: Documenta√ß√£o extensa, exemplos pr√°ticos

---

## Tecnologias Utilizadas

### Backend

- **Framework**: Spring Boot 3.5.6
- **Linguagem**: Java 17
- **Build**: Maven 3.9.x

### Frontend

- **Framework**: JavaFX 17
- **Comunica√ß√£o**: Apache HttpClient 5.2.1
- **Serializa√ß√£o**: Jackson (JSON)

### Bancos de Dados

- **PostgreSQL 16**: Dados mestres (Cadastro)
- **MongoDB 6.0**: Documentos (Agendamento)
- **Cassandra 5**: Alta disponibilidade (Estoque, Auditoria)
- **Redis 7**: Cache e Pub/Sub

### Infraestrutura

- **Containeriza√ß√£o**: Docker & Docker Compose
- **Orquestra√ß√£o**: Scripts Bash/PowerShell

---

**Vers√£o**: 1.0  
**√öltima Atualiza√ß√£o**: Dezembro de 2025  
**Equipe**: Grupo 4 - SimpleHealth
