# 3.9. Modelagem de Intera√ß√µes

Este documento apresenta os diagramas de sequ√™ncia (DS) para os principais casos de uso do sistema SimpleHealth, demonstrando as intera√ß√µes entre objetos durante a execu√ß√£o de cada funcionalidade.

## Sum√°rio

- [Notas T√©cnicas - Corre√ß√µes de Discrep√¢ncias](#notas-t√©cnicas---corre√ß√µes-de-discrep√¢ncias)
- [UC01: Cadastrar Novo Paciente](#uc01-cadastrar-novo-paciente)
- [UC02: Agendar Consulta](#uc02-agendar-consulta)
- [UC03: Solicitar Encaixe](#uc03-solicitar-encaixe)
- [UC04: Registrar Bloqueio de Agenda](#uc04-registrar-bloqueio-de-agenda)
- [UC05: Dar Baixa em Insumos](#uc05-dar-baixa-em-insumos)
- [UC06: Processar Entrada de NF/Itens](#uc06-processar-entrada-de-nfitens)
- [UC07: Gerar Alerta de Estoque Cr√≠tico](#uc07-gerar-alerta-de-estoque-cr√≠tico)
- [UC08: Consultar Hist√≥rico do Paciente](#uc08-consultar-hist√≥rico-do-paciente)
- [UC09: Cancelar Agendamento](#uc09-cancelar-agendamento)
- [UC10: Controlar Validade de Itens](#uc10-controlar-validade-de-itens)

---

## Notas T√©cnicas - Corre√ß√µes de Discrep√¢ncias

Os diagramas de sequ√™ncia foram atualizados para refletir discrep√¢ncias identificadas.

### Discrep√¢ncia 3.3: Integra√ß√£o AgendamentoService ‚Üí CadastroService

**Discrep√¢ncia:** Diagramas mostravam chamadas diretas entre servi√ßos de m√≥dulos diferentes.

**Mudan√ßa Feita:** Diagramas UC02 e UC03 simplificados para mostrar uso de strings (pacienteCpf, medicoCrm) sem depend√™ncias diretas.

**Justificativa:** Microservi√ßos n√£o t√™m depend√™ncias diretas. Integra√ß√£o via Redis Pub/Sub.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_3.3.md](../../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_3.3.md)

### Discrep√¢ncia 3.4: Integra√ß√£o AgendamentoService ‚Üí EstoqueService

**Discrep√¢ncia:** UC08 mostrava AgendamentoService integrando com EstoqueService.

**Mudan√ßa Feita:** UC08 simplificado para retornar apenas dados de Agendamento, sem integra√ß√£o com Estoque.

**Justificativa:** DarBaixaInsumosUseCase √© independente no m√≥dulo Estoque.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_3.4.md](../../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_3.4.md)

### Discrep√¢ncia 5.1: UC07 - Gerar Alerta de Estoque Cr√≠tico

**Discrep√¢ncia:** Diagrama mostrava fluxo completo, mas n√£o implementado.

**Mudan√ßa Feita:** Cabe√ßalho do UC07 marcado como `[N√ÉO IMPLEMENTADO]`.

**Justificativa:** Publisher existe, subscriber n√£o.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_5.1.md](../../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_5.1.md)

### Discrep√¢ncia 5.2: UC08 - Consultar Hist√≥rico do Paciente

**Discrep√¢ncia:** Diagrama mostrava 5 integra√ß√µes, mas apenas 3 funcionam.

**Mudan√ßa Feita:** Cabe√ßalho do UC08 marcado como `[IMPLEMENTA√á√ÉO PARCIAL]` com detalhes dos subscribers.

**Justificativa:** 3 de 5 canais Redis funcionam (consultas, exames, procedimentos).

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_5.2.md](../../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_5.2.md)

### Discrep√¢ncia 5.3: UC10 - Controlar Validade de Itens

**Discrep√¢ncia:** Diagrama mostrava persist√™ncia de descartes, mas apenas logs.

**Mudan√ßa Feita:** Cabe√ßalho do UC10 marcado como `[IMPLEMENTA√á√ÉO PARCIAL]` com nota sobre `registrarMovimentacaoDescarte()`.

**Justificativa:** M√©todo n√£o persiste em BD, apenas imprime no console.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_5.3.md](../../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_5.3.md)

---

Para consultar todas as corre√ß√µes, acesse o [üìë Sum√°rio de Corre√ß√µes](../../../Corre√ß√µes%20de%20Alinhamento/SUMARIO_CORRECAO_DISCREPANCIA.md).

---

## UC01: Cadastrar Novo Paciente

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC01 baseado no Fluxo B√°sico e Exce√ß√£o E1 do documento de Casos de Uso.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC01: Cadastrar Novo Paciente
' Baseado no Fluxo B√°sico e Exce√ß√£o E1 do documento de Casos de Uso
' e m√©todos do Diagrama de Classes.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC01 - Cadastrar Novo Paciente"

actor Secret√°ria as Actor

' Define os participantes conforme o Diagrama de Classes e Arquitetura L√≥gica
' O CadastroService atua como Controlador/Facade
participant ":CadastroService" as Service <<Service>>
participant ":PacienteRepository" as Repository <<Repository>>
entity ":Paciente" as Paciente <<Entity>>

autonumber "0."

Actor -> Service: registrarNovoPaciente(dadosPaciente)
activate Service

' Passo 4: O Sistema valida o formato e a unicidade do CPF.
Service -> Repository: pacienteExistente := findByCpf(dadosPaciente.cpf)
activate Repository

' Supondo que o Repository consulta o banco e n√£o encontra o CPF
Repository --> Service: return null
deactivate Repository

' Bloco de alternativa (alt) para tratar o Fluxo de Exce√ß√£o E1
alt "E1: CPF Duplicado" [pacienteExistente != null]
  Service --> Actor: return "Erro: CPF j√° cadastrado."
else "Fluxo B√°sico" [pacienteExistente == null]
  ' Passo 7: O Sistema salva o novo registro
  ' O Servi√ßo cria a entidade
  Service -> Paciente: <<create>> p
  activate Paciente
  
  ' O Servi√ßo comanda o Repository para salvar a entidade
  Service -> Repository: save(p)
  activate Repository
  Repository --> Service: return
  deactivate Repository
  deactivate Paciente
  
  ' Passo 8: O caso de uso √© encerrado
  Service --> Actor: return "Paciente salvo com sucesso."
end

deactivate Service

@enduml
```

### Diagrama Gerado

![UC01 - Cadastrar Novo Paciente](images/image8.png)

---

## UC02: Agendar Consulta

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC02 baseado no Fluxo B√°sico, Alternativo A1 e Exce√ß√£o E1.

**NOTA ARQUITETURAL:** Na implementa√ß√£o real, N√ÉO existe depend√™ncia direta entre AgendamentoService e CadastroService. Os m√≥dulos s√£o desacoplados e integram-se via Redis Pub/Sub (eventos). Consultas armazenam apenas pacienteCpf (String), n√£o objetos Paciente.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC02: Agendar Consulta
' Baseado no Fluxo B√°sico, Alternativo A1 e Exce√ß√£o E1.
' Demonstra a colabora√ß√£o entre diferentes servi√ßos (Agendamento e Cadastro).

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC02 - Agendar Consulta"

actor Secret√°ria as Actor

\' Participantes baseados no Diagrama de Classes
participant ":AgendamentoService" as AgService <<Service>>
participant ":AgendamentoRepository" as AgRepository <<Repository>>
entity ":Agendamento" as Agendamento <<Entity>>

autonumber "0."

' Passos 1, 2, 5, 6 do UC: Usu√°rio seleciona data, paciente, tipo e confirma
Actor -> AgService: criarAgendamento(dadosAgendamento)
activate AgService

' Passo 3: O Sistema consulta o AgendamentoService para verificar a disponibilidade.
' Esta √© uma auto-mensagem
AgService -> AgService: disponivel := verificaDisponibilidade(medicoId, dtInicio, dtFim)
activate AgService

' Supondo happy path
AgService --> AgService: return true
deactivate AgService

' Bloco 'alt' para tratar Exce√ß√£o E1 (Conflito de Agenda)
alt "E1: Conflito de Agenda" [disponivel == false]
  AgService --> Actor: return "Hor√°rio indispon√≠vel."
else "Fluxo B√°sico" [disponivel == true]
  \' Passo 4: Valida√ß√£o de dados (pacienteCpf, medicoCrm) ocorre na camada controller/frontend
  \' NOTA: N√ÉO h√° chamada direta AgendamentoService -> CadastroService
  \' Agendamento armazena apenas String (pacienteCpf, medicoCrm, convenioNome)
  
  \' Bloco \'alt\' para tratar Fluxo Alternativo A1 (Paciente N√£o Encontrado)
  alt "A1: Paciente N√£o Encontrado" [valida√ß√£o pr√©via falhou]
    AgService --> Actor: return "Paciente n√£o encontrado. Cadastrar?"
  else "Fluxo B√°sico" [dados validados]
    \' Passo 7: O Sistema salva a Consulta
    AgService -> Agendamento: <<create>> a
    activate Agendamento
    
    \' Define o atributo isEncaixe como false por padr√£o
    Agendamento -> Agendamento: setIsEncaixe(false)
    
    AgService -> AgRepository: save(a)
    activate AgRepository
    AgRepository --> AgService: return
    deactivate AgRepository
    deactivate Agendamento
    
    ' Passo 8: O caso de uso √© encerrado
    AgService --> Actor: return "Agendamento confirmado."
  end
end

deactivate AgService

@enduml
```

### Diagrama Gerado

![UC02 - Agendar Consulta](images/image5.png)

---

## UC03: Solicitar Encaixe

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC03 baseado no Fluxo B√°sico e Exce√ß√£o E1. Este UC extende UC02.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC03: Solicitar Encaixe
' Baseado no Fluxo B√°sico e Exce√ß√£o E1. Este UC extende UC02.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC03 - Solicitar Encaixe (Extende UC02)"

actor "Profissional de Sa√∫de" as Actor

' Participantes baseados no Diagrama de Classes
' NOTA: CadastroService removido - m√≥dulos s√£o desacoplados via Redis Pub/Sub
participant ":AgendamentoService" as AgService <<Service>>
participant ":AgendamentoRepository" as AgRepository <<Repository>>
entity ":Agendamento" as Agendamento <<Entity>>

autonumber "0."

' Passo 1: O Ator tenta realizar o UC02 (Agendar Consulta)
Actor -> AgService: criarAgendamento(dadosAgendamento)
activate AgService

' Passo 1 (cont.): ...mas a verifica√ß√£o de disponibilidade falha.
AgService -> AgService: disponivel := verificaDisponibilidade(medicoId, dtInicio, dtFim)
activate AgService
AgService --> AgService: return false
deactivate AgService

' Passo 2 e 3: O Sistema pergunta "Deseja solicitar um encaixe?" e o Ator confirma.
' Bloco 'alt' para o fluxo de encaixe
alt "Solicitar Encaixe" [disponivel == false]
  ' Passo 4: O Sistema verifica a permiss√£o do Ator
  ' NOTA: Valida√ß√£o de permiss√£o √© feita internamente ou na camada controller
  ' N√ÉO h√° chamada direta entre AgendamentoService e CadastroService
  AgService -> AgService: temPermissao := verificarPermissaoEncaixe(actorId)
  activate AgService
  AgService --> AgService: return true
  deactivate AgService
  
  ' Bloco 'alt' para tratar Exce√ß√£o E1 (Permiss√£o Negada)
  alt "E1: Permiss√£o Negada" [temPermissao == false]
    AgService --> Actor: return "Usu√°rio sem permiss√£o para encaixes."
  else "Fluxo B√°sico (Permiss√£o OK)" [temPermissao == true]
    ' Re-valida o paciente (como no UC02)
    AgService -> CadService: paciente := buscarPaciente(dadosAgendamento.pacienteId)
    activate CadService
    CadService --> AgService: return pacienteObjeto
    deactivate CadService
    
    ' Passo 5: O Sistema salva o Agendamento com o flag isEncaixe = true
    AgService -> Agendamento: <<create>> a
    activate Agendamento
    Agendamento -> Agendamento: setIsEncaixe(true)
    Agendamento -> Agendamento: setMotivoEncaixe(dadosAgendamento.motivo)
    
    AgService -> AgRepository: save(a)
    activate AgRepository
    AgRepository --> AgService: return
    deactivate AgRepository
    deactivate Agendamento
    
    ' Passo 6: O caso de uso √© encerrado
    AgService --> Actor: return "Encaixe confirmado."
  end
end

deactivate AgService

@enduml
```

### Diagrama Gerado

![UC03 - Solicitar Encaixe](images/image7.png)

---

## UC04: Registrar Bloqueio de Agenda

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC04 baseado no Fluxo B√°sico e Exce√ß√£o E1.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC04: Registrar Bloqueio de Agenda
' Baseado no Fluxo B√°sico e Exce√ß√£o E1.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC04 - Registrar Bloqueio de Agenda"

' Ator pode ser M√©dico ou Gestor
actor M√©dico as Actor

' Participantes baseados no Diagrama de Classes
participant ":AgendamentoService" as AgService <<Service>>
participant ":AgendamentoRepository" as AgRepository <<Repository>>
entity ":BlocoAgenda" as Bloco <<Entity>>

autonumber "0."

' Passos 1-3, 5: Ator acessa fun√ß√£o, informa dados e confirma
Actor -> AgService: registrarBloqueio(medicoId, dtInicio, dtFim, motivo)
activate AgService

' Passo 4: O Sistema verifica a exist√™ncia de Agendamentos Ativos
' O m√©todo findByPeriodo(data) √© usado para essa verifica√ß√£o
AgService -> AgRepository: agendamentos := findByPeriodo(dtInicio, dtFim)
activate AgRepository

' Supondo happy path (sem conflitos)
AgRepository --> AgService: return (listaVazia)
deactivate AgRepository

' Bloco 'alt' para tratar Exce√ß√£o E1 (Conflito com Agendamento)
alt "E1: Conflito" [agendamentos.size > 0]
  AgService --> Actor: return "Erro: J√° existem agendamentos ativos no per√≠odo."
else "Fluxo B√°sico" [agendamentos.size == 0]
  ' Passo 6: O Sistema salva o novo BlocoAgenda
  ' O UC diz que salva no AgendamentoDAO
  AgService -> Bloco: <<create>> b
  activate Bloco
  
  ' Assumindo que o AgendamentoDAO pode save um BlocoAgenda
  AgService -> AgRepository: save(b)
  activate AgRepository
  AgRepository --> AgService: return
  deactivate AgRepository
  deactivate Bloco
  
  ' Passo 7: O caso de uso √© encerrado
  AgService --> Actor: return "Bloqueio registrado com sucesso."
end

deactivate AgService

@enduml
```

### Diagrama Gerado

![UC04 - Registrar Bloqueio de Agenda](images/image10.png)

---

## UC05: Dar Baixa em Insumos

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC05 baseado no Fluxo B√°sico e Exce√ß√µes E1 e E2.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC05: Dar Baixa em Insumos
' Baseado no Fluxo B√°sico e Exce√ß√µes E1 e E2.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC05 - Dar Baixa em Insumos"

' Ator pode ser M√©dico ou Secret√°ria
actor M√©dico as Actor

' Participantes baseados no Diagrama de Classes
participant ":EstoqueService" as Service <<Service>>
participant ":EstoqueDAO" as Repository <<Repository>>

autonumber "0."

' Passos 1, 2, 4: Ator acessa fun√ß√£o, seleciona item e informa quantidade
Actor -> Service: darBaixa(itemId, quantidadeNecessaria)
activate Service

' Passo 5: O Sistema consulta o EstoqueDAO para verificar a validade e a disponibilidade.
Service -> Repository: item := buscarItemPorId(itemId)
activate Repository

' Supondo happy path
Repository --> Service: return itemEstoque
deactivate Repository

' Bloco 'alt' para tratar Exce√ß√µes E1 (Vencido) e E2 (Insuficiente)
alt "E1: Item Vencido" [itemEstoque.validade < hoje]
  Service --> Actor: return "Erro: Item vencido. Baixa negada."
else "E2: Estoque Insuficiente" [itemEstoque.quantidadeTotal < quantidadeNecessaria]
  Service --> Actor: return "Erro: Estoque insuficiente. Dispon√≠vel: " + itemEstoque.quantidadeTotal
else "Fluxo B√°sico"
  ' Passo 6: O Sistema atualiza a quantidade Total do Item no Estoque.
  ' O pr√≥prio m√©todo darBaixa(id, qtde) no Repository deve fazer isso.
  Service -> Repository: darBaixa(itemId, quantidadeNecessaria)
  activate Repository
  Repository --> Service: return
  deactivate Repository
  
  ' Passo 7: O Sistema dispara a verifica√ß√£o de Estoque Cr√≠tico (UC07)
  ' Auto-mensagem
  Service -> Service: verificarEstoqueCritico(itemId)
  activate Service
  ' A l√≥gica do UC07 (alerta) acontece aqui
  Service --> Service: return
  deactivate Service
  
  ' Passo 8: O caso de uso √© encerrado
  Service --> Actor: return "Baixa realizada com sucesso."
end

deactivate Service

@enduml
```

### Diagrama Gerado

![UC05 - Dar Baixa em Insumos](images/image9.png)

---

## UC06: Processar Entrada de NF/Itens

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC06 baseado no Fluxo B√°sico e Exce√ß√£o E2.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC06: Processar Entrada de NF/Itens
' Baseado no Fluxo B√°sico e Exce√ß√£o E2.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC06 - Processar Entrada de NF/Itens"

actor Gestor as Actor

' Participantes baseados no Diagrama de Classes
participant ":EstoqueService" as Service <<Service>>
participant ":EstoqueDAO" as Repository <<Repository>>

autonumber "0."

' Passos 1-2: Ator acessa fun√ß√£o e informa NF/Fornecedor
Actor -> Service: processarEntradaNF(dadosNF, listaItens)
activate Service

' Passo E2 (antes): O Sistema verifica se a NF √© duplicada
Service -> Repository: nfJaExiste := verificarNFDuplicada(dadosNF.numero)
activate Repository
Repository --> Service: return false
deactivate Repository

' Bloco 'alt' para tratar Exce√ß√£o E2 (NF Duplicada)
alt "E2: NF Duplicada" [nfJaExiste == true]
  Service --> Actor: return "Erro: Nota Fiscal j√° registrada."
else "Fluxo B√°sico" [nfJaExiste == false]
  ' Passo 3: O usu√°rio insere a lista de Itens
  ' Bloco 'loop' para iterar sobre os itens da NF
  loop para cada item em listaItens
    ' Passo 4: O Sistema consulta o EstoqueService (DAO)
    Service -> Repository: itemDB := buscarItemPorId(item.id)
    activate Repository
    Repository --> Service: return itemDB
    deactivate Repository
    
    ' Passo 5: O Sistema incrementa a quantidade
    ' (Assumindo um m√©todo no Repository para isso)
    Service -> Repository: registrarEntradaItem(item.id, item.quantidade, item.validade, item.lote)
    activate Repository
    Repository --> Service: return
    deactivate Repository
  end
  
  ' Passo 7: O caso de uso √© encerrado
  Service --> Actor: return "Entrada de NF processada."
end

deactivate Service

@enduml
```

### Diagrama Gerado

![UC06 - Processar Entrada de NF/Itens](images/image6.png)

---

## UC07: Gerar Alerta de Estoque Cr√≠tico **[REDU√á√ÉO DE ESCOPO - N√ÉO IMPLEMENTADO]**

### Descri√ß√£o
‚ö†Ô∏è **REDU√á√ÉO DE ESCOPO**: Este caso de uso foi planejado mas N√ÉO est√° implementado. O m√≥dulo Estoque n√£o possui subscriber Redis para processar solicita√ß√µes de alertas autom√°ticos.

Diagrama de Sequ√™ncia para UC07 baseado no Fluxo B√°sico. O Ator √© o Sistema, disparado por um gatilho (timer ou chamada de UC05/UC06).

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC07: Gerar Alerta de Estoque Cr√≠tico
' Baseado no Fluxo B√°sico. Ator √© o Sistema.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC07 - Gerar Alerta de Estoque Cr√≠tico"

' O Ator √© o Sistema, disparado por um gatilho (timer)
participant Sistema as Actor <<System>>
participant ":EstoqueService" as Service <<Service>>
participant ":EstoqueDAO" as Repository <<Repository>>

autonumber "0."

' Passo 1: O Sistema inicia a verifica√ß√£o
' (O UC05/UC06 pode chamar isso, ou um timer. Modelando o timer)
Actor -> Service: verificarEstoqueCritico()
activate Service

' Passo 2: O Sistema percorre todos os Itens ativos
' (Assumindo um m√©todo no Repository que busca itens relevantes)
Service -> Repository: itens := buscarItensParaVerificacao()
activate Repository
Repository --> Service: return (listaDeItens)
deactivate Repository

' Bloco 'loop' para iterar sobre os itens
loop para cada item em listaDeItens
  ' Passo 3 e 4: Compara quantidade e gera alerta
  alt "Estoque Cr√≠tico" [item.quantidadeTotal < item.pontoReposicao]
    ' Passo 5: O Sistema notifica o Gestor
    ' (Inferindo um servi√ßo de notifica√ß√£o)
    Service -> Sistema: notificarGestor("Estoque baixo: " + item.nome)
  end
end

' Passo 6: O caso de uso √© encerrado
Service --> Actor: return "Verifica√ß√£o conclu√≠da."

deactivate Service

@enduml
```

### Diagrama Gerado

![UC07 - Gerar Alerta de Estoque Cr√≠tico](images/image2.png)

---

## UC08: Consultar Hist√≥rico do Paciente **[IMPLEMENTA√á√ÉO PARCIAL]**

### Descri√ß√£o
‚ö†Ô∏è **IMPLEMENTA√á√ÉO PARCIAL**: Este caso de uso est√° parcialmente implementado. O `ConsultarHistoricoPacienteUseCase` publica solicita√ß√µes via Redis para 5 canais, mas apenas o m√≥dulo Agendamento responde (consultas, exames, procedimentos). Os m√≥dulos **Estoque** e **Financeiro** N√ÉO possuem subscribers, ent√£o `itensBaixados` e `pagamentos` sempre retornam vazios.

Diagrama de Sequ√™ncia para UC08 baseado no Fluxo B√°sico. O AgendamentoService orquestra, chamando outros servi√ßos.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC08: Consultar Hist√≥rico do Paciente
' Baseado no Fluxo B√°sico.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC08 - Consultar Hist√≥rico do Paciente"

actor M√©dico as Actor

\' Participantes: Cada servi√ßo trabalha com seu pr√≥prio dom√≠nio
\' NOTA: Integra√ß√£o entre m√≥dulos via Redis Pub/Sub (n√£o h√° chamadas diretas)
\' REDU√á√ÉO DE ESCOPO: Hist√≥rico de insumos (Estoque) removido do UC08
participant ":AgendamentoService" as AgService \<\<Service\>\>
participant ":AgendamentoRepository" as AgRepository \<\<Repository\>\>

autonumber "0."

' Passo 1 e 2: Ator acessa fun√ß√£o e pesquisa paciente
Actor -> AgService: consultarHistoricoCompleto(pacienteCpf)
activate AgService

' Passo 3: Valida√ß√£o de pacienteCpf ocorre na camada controller/frontend
' NOTA: Agendamento j√° possui pacienteCpf (String), n√£o precisa buscar no Cadastro
' M√≥dulos s√£o desacoplados - N√ÉO h√° chamada AgendamentoService -> CadastroService

' Bloco 'alt' para Exce√ß√£o E1 (Paciente N√£o Encontrado)
alt "E1: Paciente N√£o Encontrado" [pacienteCpf inv√°lido]
  AgService --> Actor: return "Paciente n√£o encontrado."
else "Fluxo B√°sico" [pacienteCpf v√°lido]
  \' Passo 4: O Sistema consolida a lista de Agendamentos
  AgService -> AgRepository: agendamentos := findByPacienteCpf(paciente.id)
  activate AgRepository
  AgRepository --> AgService: return (listaDeAgendamentos)
  deactivate AgRepository
  
  \' REDU√á√ÉO DE ESCOPO: Hist√≥rico de insumos n√£o √© integrado ao UC08
  \' NOTA: UC05 (Dar Baixa em Insumos) √© independente do m√≥dulo Agendamento
  \' Cada m√≥dulo consulta apenas seu pr√≥prio banco (Database per Service)
  
  \' Passo 5: O caso de uso √© encerrado
  AgService --> Actor: return historicoAgendamentos
end

deactivate AgService

@enduml
```

### Diagrama Gerado

![UC08 - Consultar Hist√≥rico do Paciente](images/image3.png)

---

## UC09: Cancelar Agendamento

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC09 baseado no Fluxo B√°sico e Exce√ß√£o E2.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC09: Cancelar Agendamento
' Baseado no Fluxo B√°sico e Exce√ß√£o E2.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC09 - Cancelar Agendamento"

actor Secret√°ria as Actor

' Participantes baseados no Diagrama de Classes
participant ":AgendamentoService" as AgService <<Service>>
participant ":AgendamentoRepository" as AgRepository <<Repository>>

autonumber "0."

' Passo 1 e 2: Ator acessa agendamento e seleciona "Cancelar"
' O m√©todo `cancelarConsulta` est√° no AgendamentoService
Actor -> AgService: cancelarConsulta(agendamentoId, motivo)
activate AgService

' Passo E2 (antes): O Sistema verifica o status do agendamento
' (Inferindo um m√©todo `buscarPorId` no DAO)
AgService -> AgRepository: ag := findById(agendamentoId)
activate AgRepository
AgRepository --> AgService: return agendamentoObjeto
deactivate AgRepository

' Bloco 'alt' para Exce√ß√£o E2 (J√° Realizado)
alt "E2: Agendamento J√° Realizado" [ag.status == "Realizado"]
  AgService --> Actor: return "Erro: N√£o √© poss√≠vel cancelar um agendamento j√° realizado."
else "Fluxo B√°sico"
  ' Passo 4: O Sistema verifica a anteced√™ncia (RN-AGENDA.3)
  AgService -> AgService: verificarPrazoCancelamento(ag.dataInicio)
  activate AgService
  ' (L√≥gica de RN-AGENDA.3 e E1 acontece aqui)
  AgService --> AgService: return
  deactivate AgService
  
  ' Passo 6: O Sistema atualiza o status
  ' (Inferindo um m√©todo de atualiza√ß√£o de status no DAO)
  AgService -> AgRepository: atualizarStatus(agendamentoId, "Cancelado", motivo)
  activate AgRepository
  AgRepository --> AgService: return
  deactivate AgRepository
  
  ' Passo 7: O caso de uso √© encerrado
  AgService --> Actor: return "Agendamento cancelado."
end

deactivate AgService

@enduml
```

### Diagrama Gerado

![UC09 - Cancelar Agendamento](images/image4.png)

---

## UC10: Controlar Validade de Itens **[REDU√á√ÉO DE ESCOPO - IMPLEMENTA√á√ÉO PARCIAL]**

> **Status de Implementa√ß√£o**: UC10 est√° **parcialmente implementado**. A busca de itens por validade (endpoint `/validade`) funciona corretamente. Por√©m, o m√©todo `registrarMovimentacaoDescarte()` apenas imprime logs no console, n√£o persiste movimenta√ß√µes em banco de dados conforme descrito no diagrama abaixo.

### Descri√ß√£o
Diagrama de Sequ√™ncia para UC10 baseado no Fluxo B√°sico. Demonstra busca de itens por validade e descarte.

### C√≥digo PlantUML

```plantuml
@startuml

' Diagrama de Sequ√™ncia para UC10: Controlar Validade de Itens
' Baseado no Fluxo B√°sico.

skinparam participant {
  BorderColor DarkSlateGray
  BackgroundColor LightGray
  ArrowColor Firebrick
}

skinparam sequence {
  LifeLineBorderColor DarkSlateGray
  ActorBorderColor Firebrick
}

title "DS: UC10 - Controlar Validade de Itens"

actor Gestor as Actor

' Participantes baseados no Diagrama de Classes
participant ":EstoqueService" as Service <<Service>>
participant ":EstoqueDAO" as Repository <<Repository>>

autonumber "0.1"

' Passo 1 e 2: Ator acessa fun√ß√£o e informa crit√©rio
' (Inferindo um m√©todo de busca no Service)
Actor -> Service: buscarItensPorCriterio(criterioData)
activate Service

' Passo 3: O Sistema busca todos os Itens
' O m√©todo `buscarPorValidade` est√° no EstoqueDAO
Service -> Repository: itens := buscarPorValidade(criterioData)
activate Repository
Repository --> Service: return (listaDeItens)
deactivate Repository

' Passo 4: O Sistema exibe a lista
Service --> Actor: return (listaDeItens)
deactivate Service

' --- Fluxo de Descarte (separado, pois depende da a√ß√£o do Gestor) ---

autonumber "0.2"

' Passo 5: O Gestor seleciona os Itens e confirma a a√ß√£o
Actor -> Service: descartarItens(listaItensParaDescarte)
activate Service

' Passo 6: O Sistema registra a sa√≠da por descarte
' Bloco 'loop' para iterar sobre os itens selecionados
loop para cada item em listaItensParaDescarte
  ' Reutiliza o m√©todo `darBaixa` do UC05, mas com motivo "Descarte"
  Service -> Repository: darBaixa(item.id, item.quantidade, "Descarte")
  activate Repository
  Repository --> Service: return
  deactivate Repository
end

' Passo 7: O caso de uso √© encerrado
Service --> Actor: return "Itens descartados com sucesso."

deactivate Service

@enduml
```

### Diagrama Gerado

![UC10 - Controlar Validade de Itens](images/image1.png)

---

## Observa√ß√µes

- Todos os diagramas seguem o padr√£o estabelecido no Diagrama de Classes
- Os Services atuam como Controllers/Facades
- DAOs s√£o respons√°veis pela persist√™ncia
- Entidades s√£o criadas dinamicamente conforme necess√°rio
- Tratamento de exce√ß√µes √© demonstrado com blocos `alt`
- Itera√ß√µes s√£o demonstradas com blocos `loop`

---

**Vers√£o**: 1.0  
**√öltima Atualiza√ß√£o**: Dezembro de 2025  
**Equipe**: Grupo 4 - SimpleHealth
