# 3.8. Boas Pr√°ticas e Padr√µes de Projeto

## Sum√°rio

- [3.8. Boas Pr√°ticas e Padr√µes de Projeto](#38-boas-pr√°ticas-e-padr√µes-de-projeto)
  - [Sum√°rio](#sum√°rio)
  - [Notas T√©cnicas - Corre√ß√µes de Discrep√¢ncias](#notas-t√©cnicas---corre√ß√µes-de-discrep√¢ncias)
  - [1. Arquitetura de Microsservi√ßos](#1-arquitetura-de-microsservi√ßos)
  - [2. Clean Architecture e Separa√ß√£o em Camadas](#2-clean-architecture-e-separa√ß√£o-em-camadas)
  - [3. Padr√µes de Projeto Implementados](#3-padr√µes-de-projeto-implementados)
    - [3.1. Repository Pattern](#31-repository-pattern)
    - [3.2. Use Case Pattern](#32-use-case-pattern)
    - [3.3. DTO Pattern (Data Transfer Object)](#33-dto-pattern-data-transfer-object)
    - [3.4. Strategy Pattern (Heran√ßa)](#34-strategy-pattern-heran√ßa)
    - [3.5. Dependency Injection](#35-dependency-injection)
  - [4. Princ√≠pios SOLID Aplicados](#4-princ√≠pios-solid-aplicados)
  - [5. Boas Pr√°ticas de C√≥digogo](#5-boas-pr√°ticas-de-c√≥digogo)
  - [6. Integra√ß√£o e Comunica√ß√£oao](#6-integra√ß√£o-e-comunica√ß√£oao)
  - [7. Testabilidade](#7-testabilidade)

---

## Notas T√©cnicas - Corre√ß√µes de Discrep√¢ncias

Este documento reflete as boas pr√°ticas implementadas no sistema. Algumas corre√ß√µes importantes:

### Discrep√¢ncia 3.1: Padr√£o DAO vs Repository (Spring Data)

**Discrep√¢ncia:** Documenta√ß√£o usava termo "DAO", mas implementa√ß√£o usa Spring Data Repository Pattern.

**Mudan√ßa Feita:** Nomenclatura corrigida para "Repository Pattern" em todo o documento.

**Justificativa:** Spring Data abstrai opera√ß√µes CRUD e queries, reduzindo c√≥digo boilerplate. Padr√£o moderno adotado no backend.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_3.1.md](../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_3.1.md)

### Discrep√¢ncia 3.2: Camada de Servi√ßo - Service vs UseCase

**Discrep√¢ncia:** Documenta√ß√£o n√£o distinguia Services (13 classes) de UseCases (47 classes).

**Mudan√ßa Feita:** Documentado que sistema usa Service Layer + UseCase Pattern combinados. Services para l√≥gica de entidade √∫nica (CRUD), UseCases para orquestra√ß√£o complexa.

**Justificativa:** Arquitetura backend tem separa√ß√£o clara de responsabilidades. Services encapsulam l√≥gica de neg√≥cio b√°sica, UseCases coordenam processos complexos envolvendo m√∫ltiplas entidades.

**Documento Detalhado:** [üìÑ CORRECAO_DISCREPANCIA_3.2.md](../../Corre√ß√µes%20de%20Alinhamento/CORRECAO_DISCREPANCIA_3.2.md)

---

Para consultar todas as corre√ß√µes de discrep√¢ncias do projeto, acesse o [üìë Sum√°rio de Corre√ß√µes](../../Corre√ß√µes%20de%20Alinhamento/SUMARIO_CORRECAO_DISCREPANCIA.md).

---

## 1. Arquitetura de Microsservi√ßos

O sistema adota arquitetura de microsservi√ßos com tr√™s servi√ßos independentes: Cadastro 
(PostgreSQL), Agendamento (MongoDB) e Estoque. Cada servi√ßo possui responsabilidade 
√∫nica e pode escalar de forma independente, promovendo desacoplamento e flexibilidade 
tecnol√≥gica.

## 2. Clean Architecture e Separa√ß√£o em Camadas

A estrutura segue os princ√≠pios de Clean Architecture com camadas bem definidas: 
‚óè‚Äã Domain: Entidades de neg√≥cio (Pessoa, Agendamento, Item) com heran√ßa e 
polimorfismo 
‚óè‚Äã Application: Use Cases, Services e DTOs isolando regras de neg√≥cio 
‚óè‚Äã Infrastructure: Repositories e integra√ß√µes externas 
‚óè‚Äã Web: Controllers REST exposindo APIs 
 
Esta separa√ß√£o garante testabilidade, manutenibilidade e conformidade com o Princ√≠pio da  
 
Responsabilidade √önica (SRP).

## 3. Padr√µes de Projeto Implementados

### 3.1. Repository Pattern

Abstra√ß√µes (JpaRepository, MongoRepository, CassandraRepository) encapsulam acesso a dados, permitindo trocar 
implementa√ß√µes sem impactar camadas superiores. O sistema utiliza Spring Data Repository Pattern.

**Implementado**: PacienteRepository, MedicoRepository, ConsultaRepository, EstoqueRepository, etc.

### 3.2. Service Layer Pattern

Classes de servi√ßo (PacienteService, MedicoService, ConsultaService) encapsulam l√≥gica de neg√≥cio b√°sica 
e opera√ß√µes CRUD relacionadas a uma √∫nica entidade. Atuam como intermedi√°rios entre Controllers e Repositories.

**Implementado**: 13 classes Service no backend (Cadastro, Agendamento, Estoque)

### 3.3. Use Case Pattern (Command Pattern)

Classes espec√≠ficas (AgendarConsultaUseCase, CadastrarNovoPacienteUseCase, DarBaixaInsumosUseCase)
encapsulam casos de uso completos que orquestram m√∫ltiplos Services e implementam regras de neg√≥cio complexas.
Facilitam testes unit√°rios e segrega√ß√£o de responsabilidades.

**Implementado**: 47 classes UseCase no backend
- Cadastro: 12 UseCases
- Agendamento: 22 UseCases
- Estoque: 13 UseCases

### 3.4. DTO Pattern (Data Transfer Object)

DTOs (PacienteDTO, AgendarConsultaDTO) desacoplam a representa√ß√£o externa das
entidades internas, evitando exposi√ß√£o de detalhes de implementa√ß√£o.

### 3.5. Strategy Pattern (Heran√ßa)

Hierarquias de classes (`Pessoa ‚Üí Usuario/Paciente/Medico`, onde Medico e Usuario s√£o classes irm√£s independentes; `Agendamento ‚Üí Consulta/Exame/Procedimento`) aplicam polimorfismo, permitindo tratamento espec√≠fico por tipo.

**Nota:** No m√≥dulo de Cadastro, `Medico` e `Usuario` s√£o entidades separadas que herdam diretamente de `Pessoa`, n√£o havendo heran√ßa entre elas. Esta arquitetura permite que um m√©dico possa existir no sistema sem necessariamente ter credenciais de acesso (Usuario).

### 3.5. Dependency Injection

Uso extensivo de inje√ß√£o de depend√™ncia via construtor (@RequiredArgsConstructor do
Lombok) promove baixo acoplamento e facilita testes com mocks.

## 4. Princ√≠pios SOLID Aplicados

**S - Single Responsibility:** Cada classe tem uma √∫nica responsabilidade (ex: PacienteServicevice gerencia apenas pacientes)

**O - Open/Closed:** Entidades abstratas (Pessoa, Agendamento) permitem extens√£o sem modifica√ß√£o

**L - Liskov Substitution:** Subclasses podem substituir superclasses sem quebrar funcionalidade

**I - Interface Segregation:** Repositories espec√≠ficos (PacienteRepository) em vez de interfaces gen√©ricas gigantes

**D - Dependency Inversion:** Camadas superiores dependem de abstra√ß√µes (interfaces Repository) n√£o de implementa√ß√µes

## 5. Boas Pr√°ticas de C√≥digogo

- **Transa√ß√µes:** `@Transactional` garantindo consist√™ncia de dados
- **Valida√ß√µes:** Centralizadas (Bean Validation, exce√ß√µes customizadas)
- **Exception Handling:** Global (`GlobalExceptionHandler`) com `@RestControllerAdvice`
- **Imutabilidade:** Parcial com Lombok (`@Data`, `@Builder`)
- **Nomenclatura:** Clara e expressiva seguindo conven√ß√µes Java
- **Enums:** Para valores controlados (`StatusAgendamentoEnum`, `ModalidadeEnum`)

## 6. Integra√ß√£o e Comunica√ß√£o√£o

Microsservi√ßos mant√™m refer√™ncias fracas (strings: CPF, CRM) evitando acoplamento de bancos. Sistema preparado para evolu√ß√£o com eventos ass√≠ncronos e mensageria.

## 7. Testabilidade

Estrutura facilita testes em m√∫ltiplos n√≠veis: unit√°rios (Use Cases isolados), integra√ß√£o (repositories) e E2E (controllers). Evid√™ncias em `RELATORIO_TESTES.md` e `TESTES_CRIADOS.md`.
 


