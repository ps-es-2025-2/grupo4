# 3.8. Boas Práticas e Padrões de Projeto

## Sumário

- [3.8. Boas Práticas e Padrões de Projeto](#38-boas-práticas-e-padrões-de-projeto)
  - [Sumário](#sumário)
  - [1. Arquitetura de Microsserviços](#1-arquitetura-de-microsserviços)
  - [2. Clean Architecture e Separação em Camadas](#2-clean-architecture-e-separação-em-camadas)
  - [3. Padrões de Projeto Implementados](#3-padrões-de-projeto-implementados)
    - [3.1. Repository Pattern](#31-repository-pattern)
    - [3.2. Use Case Pattern](#32-use-case-pattern)
    - [3.3. DTO Pattern (Data Transfer Object)](#33-dto-pattern-data-transfer-object)
    - [3.4. Strategy Pattern (Herança)](#34-strategy-pattern-herança)
    - [3.5. Dependency Injection](#35-dependency-injection)
  - [4. Princípios SOLID Aplicados](#4-princípios-solid-aplicados)
  - [5. Boas Práticas de Códigogo](#5-boas-práticas-de-códigogo)
  - [6. Integração e Comunicaçãoão](#6-integração-e-comunicaçãoão)
  - [7. Testabilidade](#7-testabilidade)

---

## 1. Arquitetura de Microsserviços

O sistema adota arquitetura de microsserviços com três serviços independentes: Cadastro 
(PostgreSQL), Agendamento (MongoDB) e Estoque. Cada serviço possui responsabilidade 
única e pode escalar de forma independente, promovendo desacoplamento e flexibilidade 
tecnológica.

## 2. Clean Architecture e Separação em Camadas

A estrutura segue os princípios de Clean Architecture com camadas bem definidas: 
●​ Domain: Entidades de negócio (Pessoa, Agendamento, Item) com herança e 
polimorfismo 
●​ Application: Use Cases, Services e DTOs isolando regras de negócio 
●​ Infrastructure: Repositories e integrações externas 
●​ Web: Controllers REST exposindo APIs 
 
Esta separação garante testabilidade, manutenibilidade e conformidade com o Princípio da  
 
Responsabilidade Única (SRP).

## 3. Padrões de Projeto Implementados

### 3.1. Repository Pattern

Abstrações (JpaRepository, MongoRepository) encapsulam acesso a dados, permitindo trocar 
implementações sem impactar camadas superiores.

### 3.2. Use Case Pattern

Classes específicas (AgendarConsultaUseCase, CadastrarNovoPacienteUseCase)
encapsulam fluxos de negócio completos, facilitando testes unitários e segregação de
responsabilidades.

### 3.3. DTO Pattern (Data Transfer Object)

DTOs (PacienteDTO, AgendarConsultaDTO) desacoplam a representação externa das
entidades internas, evitando exposição de detalhes de implementação.

### 3.4. Strategy Pattern (Herança)

Hierarquias de classes (Pessoa → Usuario/Paciente/Medico, Agendamento →
Consulta/Exame/Procedimento) aplicam polimorfismo, permitindo tratamento específico por
tipo.

### 3.5. Dependency Injection

Uso extensivo de injeção de dependência via construtor (@RequiredArgsConstructor do
Lombok) promove baixo acoplamento e facilita testes com mocks.

## 4. Princípios SOLID Aplicados

**S - Single Responsibility:** Cada classe tem uma única responsabilidade (ex: PacienteServicevice gerencia apenas pacientes)

**O - Open/Closed:** Entidades abstratas (Pessoa, Agendamento) permitem extensão sem modificação

**L - Liskov Substitution:** Subclasses podem substituir superclasses sem quebrar funcionalidade

**I - Interface Segregation:** Repositories específicos (PacienteRepository) em vez de interfaces genéricas gigantes

**D - Dependency Inversion:** Camadas superiores dependem de abstrações (interfaces Repository) não de implementações

## 5. Boas Práticas de Códigogo

- **Transações:** `@Transactional` garantindo consistência de dados
- **Validações:** Centralizadas (Bean Validation, exceções customizadas)
- **Exception Handling:** Global (`GlobalExceptionHandler`) com `@RestControllerAdvice`
- **Imutabilidade:** Parcial com Lombok (`@Data`, `@Builder`)
- **Nomenclatura:** Clara e expressiva seguindo convenções Java
- **Enums:** Para valores controlados (`StatusAgendamentoEnum`, `ModalidadeEnum`)

## 6. Integração e Comunicaçãoão

Microsserviços mantêm referências fracas (strings: CPF, CRM) evitando acoplamento de bancos. Sistema preparado para evolução com eventos assíncronos e mensageria.

## 7. Testabilidade

Estrutura facilita testes em múltiplos níveis: unitários (Use Cases isolados), integração (repositories) e E2E (controllers). Evidências em `RELATORIO_TESTES.md` e `TESTES_CRIADOS.md`.
 


